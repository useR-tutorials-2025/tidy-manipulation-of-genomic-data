---
title: "Tidyomics Workshop: Genomics Analysis"
---

## Introduction

Welcome to the Tidyomics workshop! We will be exploring how to use *tidyomics* to perform common operations for analysis and visualization of genomics data.

Before we dive into the details, we will first talk about Bioconductor, the *tidyverse* and its connection to the *tidyomics* project.

## What is Bioconductor?

Bioconductor is an open-source project that provides tools for the analysis and comprehension of high-throughput genomic data.

Bioconductor hosts many R packages that will generally fall into three categories:

-   Software packages: These packages provide data structures and analysis tools for biological data.
-   Data packages: These packages provide curated datasets for use in analysis.
-   Workflow packages: These packages contain only vignettes demonstrating usage of multiple Bioconductor packages in concert.

It is different from CRAN in particular that Bioconductor has a coordinate, biannual release cycle for all packages.

## The S4 System

S4 is one of the many frameworks for object-oriented (OO) programming in R. S4 is the [preferred class design](https://contributions.bioconductor.org/r-code.html?#class-design) for Bioconductor packages.

S4 is admittedly more complex than R's simplest OO framework, S3. The main advantages of S4 over S3 are:

-   standard generics with multiple dispatch
-   formal classes with enforced type checking / validation
-   classes with multiple inheritance

S4 provides a way to define formal classes for generic methods, allowing for more complex data structures and methods.

## The S4 System: API Best Practice

The structure of an S4 object is defined by its slots (or attributes). While you ***can*** use the `@` operator to access these slots, it is not recommended.

Instead, you should use the associated accessor functions for these slots, which are typically exported with the package. For example `assay()` for the `assay` slot. There are also setter functions, e.g. `assay()<-`.

Within Bioconductor, the internal data structure of the S4 object is subject to change, and thus the `@` operator is not considered a stable way to access data, while the accessor functions (and setters) provide a consistent API.

## The S4 System: SummarizedExperiment (SE)

The *SummarizedExperiment* (SE) class is a powerful and popular data structure in Bioconductor.

At its core, the SE stores matrix-like data in the form of "assays", and provides tables for annotation of the rows and columns.

This structure was originally described in the [2004 Bioconductor publication](https://doi.org/10.1186/gb-2004-5-10-r80), and updated as *SummarizedExperiment* in the [2015 publication](https://doi.org/10.1038/nmeth.3252). Such a data structure for annotated matrices is also implemented in for example, the [anndata](https://doi.org/10.21105/joss.04371) object in python. From the 2004 article:

> ...low-level data are bridged to high-level analysis manipulations via the \[data\] structure. The designer of low-level processing software can focus on the creation of a \[dataset\] instance, and need not cater for any particular analysis data structure representation. The designer of analysis procedures can ignore low-level structures and processes, and operate directly on the \[data\] representation. This design is responsible for the ease of interoperation of ... key Bioconductor packages...

The SE class has become the *de facto* standard in Bioconductor for storing annotated matrix-like data, and is used by many packages, including *DESeq2* and most single cell analysis packages.

```{r SE-overview, fig.align = 'center', out.width = "100%"}
#| echo: false
#| fig.cap: "Source: SummarizedExperiment [vignette](https://www.bioconductor.org/packages/devel/bioc/vignettes/SummarizedExperiment/inst/doc/SummarizedExperiment.html)"
knitr::include_graphics("figures/SE-overview.png")
```

::: callout-note
### Important

SE is widely used, but its functionality stems from other Bioconductor packages. A notable mention is *S4Vectors*:

-   provides a way to indicate your S4 object is "vector-like" (with the *Vector* virtual class) even if the underlying storage is not a vector.
-   provides a notation of size and subset generics.
-   provides a *DFrame* object. Like a *data.frame*, but columns can be any object inheriting from *Vector* (e.g. *GRanges*, *Rle*, etc.).
:::

## What is the *tidyverse*?

The *tidyverse* is a collection of R packages that specialize in providing users with consistant APIs for handeling their data. A non-exhaustive list of common *tidyverse* packages include *dplyr*, *tidyr*, and *ggplot2*. Each *tidyverse* package tends to focus on solving one problem and will offer a set of consistent APIs for their use cases.

<!-- Include more examples of tidy data? -->

## What is *tidyomics*?

Like the *tidyverse*, the *tidyomics* project aims to bring the philosolpy of the *tidyverse* to the Omics focused packages within Bioconductor.

-   <https://github.com/tidyomics> - the main website
-   [Announcement paper](https://www.biorxiv.org/content/10.1101/2023.09.10.557072v2) posted in 2023
-   `#tidiness_in_bioc` channel in the `community-bioc` Zulip (like Slack)

```{r tidyomics workflow goal}
#| echo: false
#| fig.cap: Diagram of how packages share a similar grammar
knitr::include_graphics("figures/tidyomics-workflow.png")
```

## A brief overview of *tidyomics* in practice

Like the *tidyverse*, *tidyomics* hosts many packages, and all of them aim to bring some "tidyverse" functionality to a Bioconductor package.

For example, *tidySummarizedExperiment* defines methods from *dplyr*, *tidyr*, and *ggplot2* for the *SummarizedExperiment* class, allowing users to think about their *SummarizedExperiment* objects as a "long-form *data.frame*".

Alternatively, some *tidyomics* packages will opt to only extend a niche part of the *tidyverse*. Such is the case for *plyranges* and *plyxp*, which focus on defining methods for *dplyr* for the *GenomicRanges* and *SummarizedExperiment* packages respectively.

## What is "Tidy" Data?

```{r tidy_style, echo=FALSE, fig.align = 'center', out.width = "100%", fig.cap = "Source: Hadley Wickhamâ€™s R for Data Science, 1st Edition"}
knitr::include_graphics("figures/tidy-style.png")
```

See the description here: [Tidy Data](https://r4ds.had.co.nz/tidy-data.html)

Note that:

-   One row per observation, one column per variable.
-   Genomic regions (BED) already in this format.
-   [Matrices and annotated matrices are not]{.underline}.

## *SummarizedExperiment* objects

```{r library SummarizedExpierment}
#| message: false
library(SummarizedExperiment)
set.seed(123) # some random count data
```

```{r create simple counts}
#| echo: true
counts <- matrix(
  rpois(16, lambda=100), ncol=4,
  dimnames=list(c("g1","g2","g3","g4"),
                c("s1","s2","s3","s4"))
)
counts
```

## Row data and column data

metadata about genes (rows)

```{r create simple rowdata}
genes <- DataFrame(
  id = c("g1","g2","g3","g4"),
  symbol = c("ABC","DEF","GHI","JKL")
)
genes
```

metadata about samples (columns)

```{r create simple coldata}
samples <- DataFrame(
  sample = c("s1","s2","s3","s4"),
  condition = c("x","y","x","y"),
  sex = c("m","m","f","f")
)
samples
```

## Assembled object

```{r create SE}
se <- SummarizedExperiment(
  assays = list(counts = counts),
  rowData = genes,
  colData = samples,
  metadata = list(organism="Hsapiens")
)
se
```

::: callout-note
### Example
Try to assess the `assay()`, `rowData()` and `colData()` of the `se` object.
:::

## Deals with bookkeeping issues

Reordering columns propagates to `assay` and `colData`:

```{r reorder SE}
#| echo: true
se2 <- se[,c(1,3,2,4)]
assay(se2, "counts")
colData(se2)
```

## Deals with bookkeeping issues

Assignment with conflicting metadata gives an error:

```{r assignment failure bookeeping}
#| echo: true
#| eval: false
assay(se2) <- counts
# Error in `assays<-`:
# please use 'assay(x, withDimnames=FALSE)) <- value' or
# 'assays(x, withDimnames=FALSE)) <- value'
# when the rownames or colnames of the supplied assay(s) are not
# identical to those of the receiving  SummarizedExperiment object 'x'
```

-   Other such validity checks include comparison across *different reference genome versions*.

-   Errors triggered by metadata better than silent errors!

## Can be hard for new users

```{r show slots and methods}
#| echo: true
slotNames(se)
methods(class = class(se)) |> head()
```

-   An advanced R/Bioconductor user should eventually learn these methods, class/method inheritance.

-   Not needed to explore or visualize data, or make basic data summaries.

## Beginners know *dplyr* & *ggplot2*

```{r load dplyr}
#| echo: true
#| message: false
library(dplyr)
# filter to samples in condition 'x'
samples |>
  as_tibble() |>
  filter(condition == "x")
```

## Enabling *dplyr* verbs for omics

-   *tidySummarizedExperiment* package from Mangiola *et al.*

-   Printing says: "*SummarizedExperiment-tibble abstraction*"

```{r load tidySE}
#| echo: true
#| message: false
library(tidySummarizedExperiment)
se
```

If you prefer for the old S4 `show` method to be used:

```{r unset tidySE show}
options("restore_SummarizedExperiment_show" = TRUE)
se
```

::: callout-note
Calling `print(se)` even after restoring `show()` will still use the "tibble-abstraction"!
:::

## The API

```{r simple tidySE}
#| echo: true
se2 <- se |>
  filter(condition == "x")

se2
colData(se2)
```

## Facilitates quick exploration

```{r set ggplot2 theme}
#| message: false
#| echo: false
library(ggplot2)
theme_set(theme_grey(base_size = 16))
```

```{r ggplot}
#| message: false
#| echo: true
#| fig-align: center
library(ggplot2)
se |>
  filter(.feature %in% c("g1","g2")) |> # `.feature` a special name
  ggplot(aes(condition, counts, color=sex, group=sex)) +
  geom_point(size=2) + geom_line() + facet_wrap(~.feature)
```

## Efficient operation on SE with *plyxp*

-   Justin Landis (UNC BCB) noticed some opportunities for more efficient operations.

-   Also, reduce ambiguity, allow multiple ways to access data across context. Leveraging data masks from *rlang*.

-   Developed in Summer 2024: *plyxp*, stand-alone but also as a *tidySummarizedExperiment* engine.

![](figures/plyxp.png){fig-align="center"}

## To use *plyxp*

Start by wraping any class inheriting from *SummarizedExperiment* with *plyxp*'s thin wrapper class:

```{r load and use plyxp}
#| message: false
#| warning: false
library(plyxp)
xp <- new_plyxp(se)
xp |> class() |> getClass()
```

::: callout-note
Unlike *tidySummarizedExperiment*, *plyxp* only extends *dplyr*. Thus you cannot pipe output from *plyxp* into *tidyr* or *ggplot2* ([*yet*]{.underline}). However you can always retrieve the underlying *SummarizedExperiment* object via the `se()` function.

```{r plyxp get se}
se(xp)
```
:::


## Using *plyxp*

*plyxp* is a stricter version of *tidySummarizedExperiment*. It's grammar reinforces the underlying structure of the *SummarizedExperiment* class. It provides evaluation contexts that allow the user to specify where and how expressions are evaluated.

![A SummarizedExperiment has three evaluation contexts: the assays, rowData, and colData. Figure made with [BioRender](BioRender.com)](figures/plyxp-bindings.png){fig-align="center" fig-alt="A depiction of a SummarizedExperiment object and its bindings to three evaluation contexts: the assays, row-data, and col-data."}

## Using *plyxp* cont.

*plyxp* allows optional access into the other contexts with special [**pronouns**]{.underline}. These will reshape the data for something convenient for the current context. There also exists special **\_asis** variants that do not reshape the data.

![Each context contains special pronouns that point to the other contexts. The special **\_asis** variants are not shown here. Figure made with [BioRender](BioRender.com)](figures/plyxp-pronouns.png){fig-align="center" fig-alt="A depiction of a SummarizedExperiment object's three evaluation contexts and the pronouns within."}

## The "airway" dataset

We have a matrix of count data from an RNA-seq experiment of airway smooth muscle cell lines. The counts reflect detected RNA copies of a gene (row) across different samples (column). This is a *RangedSummarizedExperiment* which indicates genomic ranges are used.

The most important pieces of metadata we will examine are `cell`, which indicates the human donor, and `dex` which indicates which samples are treated with a compound or untreated. The `gene_biotype` metadata variable gives us some minimal information about the gene function.

```{r load airway}
library(airway)
data(airway)
airway
```

We now have a quick suggested clean-up of the dataset, peculiar to `airway`. Please run the following lines of code, which clean up metadata in the object.

```{r cleanup}
dimnames(assay(airway, "counts")) <- dimnames(airway)
# save the exonic length (sum of reduced exon width...)
rowData(airway)$exonic_length <- sum(width(reduce(rowRanges(airway))))
rowRanges(airway) <- NULL # ignore ranges here
```

The columns are our 8 samples, and the rows are the genes.

```{r show airway metadata}
rowData(airway)
colData(airway)
```

## airway with *plyxp*

```{r boxplot of cells and treatment}
airxp <- new_plyxp(airway)
airxp

airxp |>
  se() |>
  ggplot(aes(x = cell, y = log1p(counts), fill = dex)) +
  geom_boxplot() +
  guides(x = guide_axis(angle = 45))
```

::: callout-note
### Example
Try to subset the object to the samples with `dex` variable (on the samples) equal to `trt`. Try this both with base Bioconductor `[,]` or with *plyxp* code.
:::

A common operation is to calculate the RPKM (Reads Per Kilobase of transcript, per Million mapped reads) or TPM (Transcripts Per Million) values for each gene in each sample. This can be computed by dividing the counts by the column sum, dividing out gene length, and ensuring the columns sum to 1 million.

We can compute this in several steps below, and then compute the row mean of this new computed matrix.

::: callout-note
### Example
Try the following code one piece at a time, e.g. first the `rows()` operation adding gene lengths, etc.
:::

```{r compute TPM}
airxp <- airxp |>
  mutate(
    # calculate read count per kilobase of gene length (sum of exons)
    RPK = counts / (.rows$exonic_length / 1e3),
    cols(
      # calculate a scale factor for each sample (column sum)
      scale_factor = colSums(.assays_asis$RPK) / 1e6
    ),
    # calculate transcript count per million (TPM) by dividing out scale factor
    TPM = RPK / .cols$scale_factor,
    # calculate the mean of the new scaled TPM values per gene
    rows(gene_scaled_means = rowMeans(.assays_asis$TPM))
  )

```

::: callout-note
### TPM column Sum
Try to verify that the TPM values sum to 1 million for each sample.
:::

```{r plot boxplot filter}
airxp_sub <- airxp |>
  filter(
    rows(
      # only investigate protein coding genes
      gene_biotype == "protein_coding",
      # retain genes whose counts across all samples is non-zero
      gene_scaled_means > 5
    )
  )
airxp_sub
airxp_sub |>
  se() |>
  ggplot(aes(x = cell, y = log1p(counts), fill = dex)) +
  geom_boxplot() +
  guides(x = guide_axis(angle = 45))
```

Attempt to find the top 100 genes that have the greatest change between "trt" and "untrt" within each cell.

::: callout-note
### Example
Try the following chunk up to but not including the first `mutate()`.
:::

```{r find diff between treatment groups}
airxp_ave <- airxp_sub |>
  group_by(
    # do not need to group_by rows(gene_id) ...
    # this will create ~ 17,000 additional groups per row!
    # instead we can choose to only split by the columns and
    # use vectorized functions
    cols(cell)
  ) |>
  summarize(
    # use the `.cols$dex` metadata vector to index the `counts`
    abs_diff = abs(counts[.cols$dex=="trt"] - counts[.cols$dex=="untrt"]),
    cols(.samples = unique(cell))
  ) |>
  mutate(
    # for each gene, find the mean absolute diff across
    # all cells
    rows(ave = rowMeans(.assays_asis$abs_diff))
  )

rowData(airxp_ave)["ave"]
```

```{r top 100 genes}
top_100_genes <- airxp_ave |>
  arrange(rows(-ave)) |>
  _[1:100,] |>
  pull(rows(gene_id))
```

The grouping is very powerful functionality here.

Another way to accomplish this computation would involve arranging the matrices by sample, but this puts more responsibility on the user to ensure values are arranged properly.

For example:

```{r ex arrange and colData}
airxp_sub |>
  arrange(cols(dex, cell)) |>
  colData()
```

```{r ex arrange and ave}
airxp_arr <- airxp_sub |>
  arrange(cols(dex, cell))

airxp_arr_ave <- airxp_arr |>
  mutate(
    rows(
      ave = rowMeans(abs(
        .assays_asis$counts[, 1:4] -
          .assays_asis$counts[, 5:8]
      ))
    )
  )

rowData(airxp_arr_ave)["ave"]
```

```{r line plot of top 6 genes}
top_6 <- head(top_100_genes, 6)
airxp_sub |>
  filter(rows(gene_id %in% top_6)) |>
  se() |>
  ggplot(aes(x = dex, y = log1p(counts), group = cell)) +
  geom_point() +
  geom_line() +
  facet_wrap(~.feature)
```

It is common for a user to visualize data with a heatmap. We can create a function that will cluster the rows and columns of a summarized expeirment based on the values in a given assay name.

```{r ex cluster function with plyxp internal}
#' Cluster rows and columns of a plyxp object based on an assay
#' @param xp A plyxp object
#' @param assay a unquoted name of an assay to use for clustering
#' @param rows_k number of row clusters to create (optional)
#' @param cols_k number of column clusters to create (optional)
#' @return A plyxp object with rows ordered by rows(features) and cols(samples). optional groupings assigned to rows(row_cluster) and cols(col_cluster).
cluster_xp <- function(xp, assay, rows_k = NULL, cols_k = NULL) {
  assay_val <- pull(xp, {{ assay }})
  row_hc <- hclust(dist(assay_val))
  col_hc <- hclust(dist(t(assay_val)))
  ## apply a function on the metadata
  xp <- plyxp_on(xp, .on = metadata, \(md) {
    md$row_hc <- row_hc
    md$col_hc <- col_hc
    md
  })

  xp <- xp |>
   mutate(
     rows(features = factor(.features, levels = .features[row_hc$order])),
     cols(samples  = factor(.samples,  levels = .samples[col_hc$order]))
   )
  if (!is.null(rows_k)) {
    xp <- xp |>
      group_by(
        rows(row_cluster = factor(cutree(row_hc, k = rows_k))),
        .add = TRUE
      )
  }
  if (!is.null(cols_k)) {
    xp <- xp |>
      group_by(
        cols(col_cluster = factor(cutree(col_hc, k = cols_k))),
        .add = TRUE
      )
  }
  xp
}
```

```{r heatmap of top 100 genes clustered by counts}
airxp_sub |>
  filter(rows(gene_id %in% top_100_genes)) |>
  cluster_xp(counts, rows_k = 4, cols_k = 3) |>
  se() |>
  ggplot(aes(x = samples, y = features, fill = log1p(counts))) +
  geom_tile() +
  viridis::scale_fill_viridis() +
  guides(x = guide_axis(angle = 45)) +
  facet_grid(rows = vars(row_cluster),
   cols = vars(col_cluster), scales = "free", space = "free") +
  scale_y_discrete(labels = NULL)

```

```{r heatmap of top 100 genes clustered by TPM}
airxp_sub |>
  filter(rows(gene_id %in% top_100_genes)) |>
  cluster_xp(TPM) |>
  se() |>
  ggplot(aes(x = samples, y = features, fill = log1p(TPM))) +
  geom_tile() +
  viridis::scale_fill_viridis() +
  guides(x = guide_axis(angle = 45)) +
  scale_y_discrete(labels = NULL)
```
